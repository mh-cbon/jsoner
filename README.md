# jsoner

[![travis Status](https://travis-ci.org//mh-cbon/jsoner.svg?branch=master)](https://travis-ci.org//mh-cbon/jsoner) [![Appveyor Status](https://ci.appveyor.com/api/projects/status//github/mh-cbon/jsoner?branch=master&svg=true)](https://ci.appveyor.com/projects//mh-cbon/jsoner) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/jsoner)](https://goreportcard.com/report/github.com/mh-cbon/jsoner) [![GoDoc](https://godoc.org/github.com/mh-cbon/jsoner?status.svg)](http://godoc.org/github.com/mh-cbon/jsoner) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package jsoner is a cli tool to implement json-rpc of a type.


s/Choose your gun!/[Aux armes!](https://www.youtube.com/watch?v=hD-wD_AMRYc&t=7)/

# TOC
- [Install](#install)
  - [Usage](#usage)
    - [$ jsoner -help](#-jsoner--help)
  - [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/lib.go](#-demolibgo)
  - [> demo/json_vegetables_gen.go](#-demojson_vegetables_gengo)
  - [> demo/json_controller_gen.go](#-demojson_controller_gengo)
  - [Conventionned variable name](#conventionned-variable-name)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install
```sh
mkdir -p $GOPATH/src/github.com/mh-cbon/jsoner
cd $GOPATH/src/github.com/mh-cbon/jsoner
git clone https://github.com/mh-cbon/jsoner.git .
glide install
go install
```

## Usage

#### $ jsoner -help
```sh
jsoner 0.0.0

Usage

	jsoner [-p name] [out] [...types]

	out:   Output destination of the results, use '-' for stdout.
	types: A list of types such as src:dst.
	-p:    The name of the package output.
```

## Cli examples

```sh
# Create a jsoned version of Tomate to MyTomate
jsoner tomate_gen.go Tomate:MyTomate
```

# API example

Following example demonstates a program using it to generate a jsoned version of a type.

#### > demo/lib.go
```go
package demo

//go:generate lister vegetables_gen.go Tomate:Tomates
//go:generate jsoner json_vegetables_gen.go *Tomates:JSONTomates

// Tomate if the resource subject.
type Tomate struct {
	Name string
}

// GetID ...
func (t Tomate) GetID() string {
	return t.Name
}

//go:generate jsoner json_controller_gen.go *Controller:JSONController

// Controller of some resources.
type Controller struct {
}

// GetByID ...
func (t Controller) GetByID(id int) Tomate {
	return Tomate{}
}

// UpdateByID ...
func (t Controller) UpdateByID(id int, reqBody Tomate) Tomate {
	return Tomate{}
}

// DeleteByID ...
func (t *Controller) DeleteByID(reqID int) bool {
	return false
}
```

Following code is the generated implementation of a typed slice of `Tomate`.

#### > demo/json_vegetables_gen.go
```go
package demo

// file generated by
// github.com/mh-cbon/jsoner
// do not edit

import (
	"bytes"
	"encoding/json"
	"io"
)

// JSONTomates is jsoner of *Tomates.
type JSONTomates struct {
	embed *Tomates
}

// NewJSONTomates constructs a jsoner of *Tomates
func NewJSONTomates(embed *Tomates) *JSONTomates {
	ret := &JSONTomates{
		embed: embed,
	}
	return ret
}

// Push reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Push(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar0 := t.embed.Push(input.x...)

	out, encErr := json.Marshal([]interface{}{retVar0})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Unshift reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Unshift(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar1 := t.embed.Unshift(input.x...)

	out, encErr := json.Marshal([]interface{}{retVar1})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Pop reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Pop(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	retVar2 := t.embed.Pop()

	out, encErr := json.Marshal([]interface{}{retVar2})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Shift reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Shift(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	retVar3 := t.embed.Shift()

	out, encErr := json.Marshal([]interface{}{retVar3})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Index reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Index(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar4 := t.embed.Index(input.s)

	out, encErr := json.Marshal([]interface{}{retVar4})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Contains reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Contains(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar5 := t.embed.Contains(input.s)

	out, encErr := json.Marshal([]interface{}{retVar5})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// RemoveAt reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) RemoveAt(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		i int
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar6 := t.embed.RemoveAt(input.i)

	out, encErr := json.Marshal([]interface{}{retVar6})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Remove reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Remove(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar7 := t.embed.Remove(input.s)

	out, encErr := json.Marshal([]interface{}{retVar7})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// InsertAt reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) InsertAt(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		i int
		s Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar8 := t.embed.InsertAt(input.i, input.s)

	out, encErr := json.Marshal([]interface{}{retVar8})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Splice reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Splice(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		start  int
		length int
		s      []Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar9 := t.embed.Splice(input.start, input.length, input.s...)

	out, encErr := json.Marshal([]interface{}{retVar9})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Slice reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Slice(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		start  int
		length int
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar10 := t.embed.Slice(input.start, input.length)

	out, encErr := json.Marshal([]interface{}{retVar10})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Reverse reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Reverse(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	retVar11 := t.embed.Reverse()

	out, encErr := json.Marshal([]interface{}{retVar11})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Len reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Len(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	retVar12 := t.embed.Len()

	out, encErr := json.Marshal([]interface{}{retVar12})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Set reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Set(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar13 := t.embed.Set(input.x)

	out, encErr := json.Marshal([]interface{}{retVar13})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Get reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) Get(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	retVar14 := t.embed.Get()

	out, encErr := json.Marshal([]interface{}{retVar14})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// At reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONTomates) At(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		i int
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar15 := t.embed.At(input.i)

	out, encErr := json.Marshal([]interface{}{retVar15})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}
```

Following code is the generated implementation of a jsoner `Controller` that uses conventionend variable name.

#### > demo/json_controller_gen.go
```go
package demo

// file generated by
// github.com/mh-cbon/jsoner
// do not edit

import (
	"bytes"
	"encoding/json"
	"io"
)

// JSONController is jsoner of *Controller.
type JSONController struct {
	embed *Controller
}

// NewJSONController constructs a jsoner of *Controller
func NewJSONController(embed *Controller) *JSONController {
	ret := &JSONController{
		embed: embed,
	}
	return ret
}

// GetByID reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONController) GetByID(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		id int
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar0 := t.embed.GetByID(input.id)

	out, encErr := json.Marshal([]interface{}{retVar0})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// UpdateByID reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONController) UpdateByID(args io.Reader) (io.Reader, error) {

	var ret io.Reader
	var retErr error

	input := struct {
		id      int
		reqBody Tomate
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	retVar1 := t.embed.UpdateByID(input.id, input.reqBody)

	out, encErr := json.Marshal([]interface{}{retVar1})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// DeleteByID reads json, outputs json.
// the json input must provide a key/value for each params.
func (t *JSONController) DeleteByID(reqID int) (io.Reader, error) {
	var ret io.Reader
	var retErr error

	retVar2 := t.embed.DeleteByID(reqID)

	out, encErr := json.Marshal([]interface{}{retVar2})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr
}
```

#### Conventionned variable name

`jsoner` reads and interprets input params to determine where/how the request body should be decoded.

In that matters it looks up for variable named `reqBody`,
if such variable is found, then the body is decoded according to its type.
Other parameters are passed/received untouched.

If such variable is not found, it is assumed that all parameters are to be decoded from the request body.

# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)
