# jsoner

[![travis Status](https://travis-ci.org/mh-cbon/jsoner.svg?branch=master)](https://travis-ci.org/mh-cbon/jsoner) [![Appveyor Status](https://ci.appveyor.com/api/projects/status/github/mh-cbon/jsoner?branch=master&svg=true)](https://ci.appveyor.com/projects/mh-cbon/jsoner) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/jsoner)](https://goreportcard.com/report/github.com/mh-cbon/jsoner) [![GoDoc](https://godoc.org/github.com/mh-cbon/jsoner?status.svg)](http://godoc.org/github.com/mh-cbon/jsoner) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package jsoner is a cli tool to implement json-rpc of a type.


s/Choose your gun!/[Aux armes!](https://www.youtube.com/watch?v=hD-wD_AMRYc&t=7)/

# TOC
- [Install](#install)
  - [Usage](#usage)
    - [$ jsoner -help](#-jsoner--help)
  - [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/lib.go](#-demolibgo)
  - [> demo/json_vegetables_gen.go](#-demojson_vegetables_gengo)
  - [> demo/json_controller_gen.go](#-demojson_controller_gengo)
  - [Conventionned variable name](#conventionned-variable-name)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install
```sh
mkdir -p $GOPATH/src/github.com/mh-cbon/jsoner
cd $GOPATH/src/github.com/mh-cbon/jsoner
git clone https://github.com/mh-cbon/jsoner.git .
glide install
go install
```

## Usage

#### $ jsoner -help
```sh
jsoner 0.0.0

Usage

	jsoner [-p name] [out] [...types]

	out:   Output destination of the results, use '-' for stdout.
	types: A list of types such as src:dst.
	-p:    The name of the package output.
	-mode: The mode of generation to apply: std|gorilla (defaults to std).
```

## Cli examples

```sh
# Create a jsoned version of Tomate to MyTomate
jsoner tomate_gen.go Tomate:MyTomate
```

# API example

Following example demonstates a program using it to generate a jsoned version of a type.

#### > demo/lib.go
```go
package demo

//go:generate lister vegetables_gen.go Tomate:Tomates
//go:generate jsoner json_vegetables_gen.go *Tomates:JSONTomates

// Tomate if the resource subject.
type Tomate struct {
	Name string
}

// GetID ...
func (t Tomate) GetID() string {
	return t.Name
}

//go:generate jsoner json_controller_gen.go *Controller:JSONController

// Controller of some resources.
type Controller struct {
}

// GetByID ...
func (t Controller) GetByID(id int) Tomate {
	return Tomate{}
}

// UpdateByID ...
func (t Controller) UpdateByID(GETid int, reqBody Tomate) Tomate {
	return Tomate{}
}

// DeleteByID ...
func (t *Controller) DeleteByID(reqID int) bool {
	return false
}
```

Following code is the generated implementation of a typed slice of `Tomate`.

#### > demo/json_vegetables_gen.go
```go
package demo

// file generated by
// github.com/mh-cbon/jsoner
// do not edit

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
)

// JSONTomates is jsoner of *Tomates.
// Tomates implements a typed slice of Tomate
type JSONTomates struct {
	embed *Tomates
}

// NewJSONTomates constructs a jsoner of *Tomates
func NewJSONTomates(embed *Tomates) *JSONTomates {
	ret := &JSONTomates{
		embed: embed,
	}
	return ret
}

// HandleSuccess prints http 200 and prints r.
func (t *JSONTomates) HandleSuccess(w io.Writer, r io.Reader) error {
	if x, ok := w.(http.ResponseWriter); ok {
		x.WriteHeader(http.StatusOK)
		x.Header().Set("Content-Type", "application/json")
	}
	_, err := io.Copy(w, r)
	return err
}

// Push Decodes r as json to invoke *Tomates.Push.
// Push appends every Tomate
func (t *JSONTomates) Push(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar0 := t.embed.Push(input.x...)

	out, encErr := json.Marshal([]interface{}{retVar0})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Unshift Decodes r as json to invoke *Tomates.Unshift.
// Unshift prepends every Tomate
func (t *JSONTomates) Unshift(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar1 := t.embed.Unshift(input.x...)

	out, encErr := json.Marshal([]interface{}{retVar1})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Pop Decodes r as json to invoke *Tomates.Pop.
// Pop removes then returns the last Tomate.
func (t *JSONTomates) Pop(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar2 := t.embed.Pop()

	out, encErr := json.Marshal([]interface{}{retVar2})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Shift Decodes r as json to invoke *Tomates.Shift.
// Shift removes then returns the first Tomate.
func (t *JSONTomates) Shift(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar3 := t.embed.Shift()

	out, encErr := json.Marshal([]interface{}{retVar3})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Index Decodes r as json to invoke *Tomates.Index.
// Index of given Tomate. It must implements Ider interface.
func (t *JSONTomates) Index(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar4 := t.embed.Index(input.s)

	out, encErr := json.Marshal([]interface{}{retVar4})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Contains Decodes r as json to invoke *Tomates.Contains.
// Contains returns true if s in is t.
func (t *JSONTomates) Contains(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar5 := t.embed.Contains(input.s)

	out, encErr := json.Marshal([]interface{}{retVar5})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// RemoveAt Decodes r as json to invoke *Tomates.RemoveAt.
// RemoveAt removes a Tomate at index i.
func (t *JSONTomates) RemoveAt(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		i int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar6 := t.embed.RemoveAt(input.i)

	out, encErr := json.Marshal([]interface{}{retVar6})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Remove Decodes r as json to invoke *Tomates.Remove.
// Remove removes given Tomate
func (t *JSONTomates) Remove(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar7 := t.embed.Remove(input.s)

	out, encErr := json.Marshal([]interface{}{retVar7})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// InsertAt Decodes r as json to invoke *Tomates.InsertAt.
// InsertAt adds given Tomate at index i
func (t *JSONTomates) InsertAt(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		i int
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar8 := t.embed.InsertAt(input.i, input.s)

	out, encErr := json.Marshal([]interface{}{retVar8})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Splice Decodes r as json to invoke *Tomates.Splice.
// Splice removes and returns a slice of Tomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *JSONTomates) Splice(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		start  int
		length int
		s      []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar9 := t.embed.Splice(input.start, input.length, input.s...)

	out, encErr := json.Marshal([]interface{}{retVar9})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Slice Decodes r as json to invoke *Tomates.Slice.
// Slice returns a copied slice of Tomate, starting at start, ending at start+length.
func (t *JSONTomates) Slice(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		start  int
		length int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar10 := t.embed.Slice(input.start, input.length)

	out, encErr := json.Marshal([]interface{}{retVar10})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Reverse Decodes r as json to invoke *Tomates.Reverse.
// Reverse the slice.
func (t *JSONTomates) Reverse(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar11 := t.embed.Reverse()

	out, encErr := json.Marshal([]interface{}{retVar11})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Len Decodes r as json to invoke *Tomates.Len.
// Len of the slice.
func (t *JSONTomates) Len(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar12 := t.embed.Len()

	out, encErr := json.Marshal([]interface{}{retVar12})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Set Decodes r as json to invoke *Tomates.Set.
// Set the slice.
func (t *JSONTomates) Set(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar13 := t.embed.Set(input.x)

	out, encErr := json.Marshal([]interface{}{retVar13})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Get Decodes r as json to invoke *Tomates.Get.
// Get the slice.
func (t *JSONTomates) Get(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar14 := t.embed.Get()

	out, encErr := json.Marshal([]interface{}{retVar14})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// At Decodes r as json to invoke *Tomates.At.
// At return the item at index i.
func (t *JSONTomates) At(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		i int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar15 := t.embed.At(input.i)

	out, encErr := json.Marshal([]interface{}{retVar15})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}
```

Following code is the generated implementation of a jsoner `Controller` that uses conventionend variable name.

#### > demo/json_controller_gen.go
```go
package demo

// file generated by
// github.com/mh-cbon/jsoner
// do not edit

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
)

// JSONController is jsoner of *Controller.
// Controller of some resources.
type JSONController struct {
	embed *Controller
}

// NewJSONController constructs a jsoner of *Controller
func NewJSONController(embed *Controller) *JSONController {
	ret := &JSONController{
		embed: embed,
	}
	return ret
}

// HandleSuccess prints http 200 and prints r.
func (t *JSONController) HandleSuccess(w io.Writer, r io.Reader) error {
	if x, ok := w.(http.ResponseWriter); ok {
		x.WriteHeader(http.StatusOK)
		x.Header().Set("Content-Type", "application/json")
	}
	_, err := io.Copy(w, r)
	return err
}

// GetByID Decodes r as json to invoke *Controller.GetByID.
// GetByID ...
func (t *JSONController) GetByID(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		id int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar0 := t.embed.GetByID(input.id)

	out, encErr := json.Marshal([]interface{}{retVar0})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// UpdateByID Decodes reqBody as json to invoke *Controller.UpdateByID.
// Other parameters are passed straight
// UpdateByID ...
func (t *JSONController) UpdateByID(GETid int, reqBody io.Reader) (io.Reader, error) {
	ret := new(bytes.Buffer)
	var retErr error

	var decBody Tomate
	decErr := json.NewDecoder(reqBody).Decode(&decBody)
	if decErr != nil {
		return nil, decErr
	}

	retVar1 := t.embed.UpdateByID(GETid, decBody)

	out, encErr := json.Marshal([]interface{}{retVar1})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr
}

// DeleteByID Decodes reqBody as json to invoke *Controller.DeleteByID.
// Other parameters are passed straight
// DeleteByID ...
func (t *JSONController) DeleteByID(reqID int) (io.Reader, error) {
	ret := new(bytes.Buffer)
	var retErr error

	retVar2 := t.embed.DeleteByID(reqID)

	out, encErr := json.Marshal([]interface{}{retVar2})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr
}
```

#### Conventionned variable name

`jsoner` reads and interprets input params to determine where/how the request body should be decoded.

In that matters it looks up for variable named `reqBody`,
if such variable is found, then the body is decoded according to its type.
Other parameters are passed/received untouched.

If such variable is not found, it is assumed that all parameters are to be decoded from the request body.

# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)
