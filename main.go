// Package jsoner is a cli tool to implement json-rpc of a type.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/loader"

	"github.com/mh-cbon/astutil"
	httper "github.com/mh-cbon/httper/lib"
)

var name = "jsoner"
var version = "0.0.0"

func main() {

	var help bool
	var h bool
	var ver bool
	var v bool
	var outPkg string
	var mode string
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	flag.StringVar(&outPkg, "p", os.Getenv("GOPACKAGE"), "Package name of the new code.")
	flag.StringVar(&mode, "mode", "std", "Generation mode.")

	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 2 {
		panic("wrong usage")
	}
	args := flag.Args()

	pkgToLoad := getPkgToLoad()
	dest := os.Stdout

	o := args[0]
	restargs := args[1:]

	prog := astutil.GetProgram(pkgToLoad)
	pkg := prog.Package(pkgToLoad)
	// astutil.PrintPkg(p)

	// foundTypes := astutil.FindTypes(pkg)
	foundMethods := astutil.FindMethods(pkg)

	if o != "-" {
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			cmd := exec.Command("go", "fmt", args[0])
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			cmd.Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", outPkg)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintf(dest, "// github.com/mh-cbon/%v\n", name)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, "")
	fmt.Fprintf(dest, "import (\n")
	fmt.Fprintf(dest, "	%q\n", "bytes")
	fmt.Fprintf(dest, "	%q\n", "encoding/json")
	fmt.Fprintf(dest, "	%q\n", "io")
	fmt.Fprintf(dest, "	%q\n", "net/http")

	var tBuf bytes.Buffer
	var extraImports []string
	for _, todo := range restargs {
		y := strings.Split(todo, ":")
		if len(y) != 2 {
			panic("wrong name " + todo)
		}
		srcName := y[0]
		destName := y[1]

		Imports, res := processType(mode, destName, srcName, prog, pkg, foundMethods)
		io.Copy(&tBuf, &res)
		extraImports = append(extraImports, Imports...)
	}

	// add extra imports
	for _, i := range extraImports {
		importPath := astutil.GetImportPath(pkg, i)
		if !(importPath == "bytes" ||
			importPath == "encoding/json" ||
			importPath == "net/http" ||
			importPath == "io") {
			if importPath == "" || strings.HasSuffix(importPath, i) {
				fmt.Fprintf(dest, "	%q\n", importPath)
			} else {
				fmt.Fprintf(dest, " %v	%q\n", i, importPath)
			}
		}
	}

	fmt.Fprintf(dest, ")\n")
	io.Copy(dest, &tBuf)
}

func showVer() {
	fmt.Printf("%v %v\n", name, version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	%v [-p name] [out] [...types]\n\n", name)
	fmt.Printf("	out:   Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	types: A list of types such as src:dst.\n")
	fmt.Printf("	-p:    The name of the package output.\n")
	fmt.Printf("	-mode: The mode of generation to apply: std|gorilla (defaults to std).\n")
	fmt.Println()
}

func processType(mode, destName, srcName string, prog *loader.Program, pkg *loader.PackageInfo, foundMethods map[string][]*ast.FuncDecl) ([]string, bytes.Buffer) {

	extraImports := []string{}
	var b bytes.Buffer
	dest := &b

	srcConcrete := astutil.GetUnpointedType(srcName)

	// the json input must provide a key/value for each params.
	structType := astutil.FindStruct(pkg, srcConcrete)
	structComment := astutil.GetComment(prog, structType.Pos())
	// todo: might do better to send only annotations or do other improvemenets.
	structComment = makeCommentLines(structComment)

	fmt.Fprintf(dest, `
%v.
// %v is jsoner of %v.
type %v struct{
	embed %v
}
		`, structComment, destName, srcName, destName, srcName)

	dstStar := astutil.GetPointedType(destName)
	dstConcrete := astutil.GetUnpointedType(destName)
	hasHandleError := methodsContains(srcName, "HandleError", foundMethods)
	hasHandleSuccess := methodsContains(srcName, "HandleSuccess", foundMethods)

	// Make the constructor
	fmt.Fprintf(dest, `// New%v constructs a jsoner of %v
func New%v(embed %v) %v {
	ret := &%v{
		embed: embed,
	}
  return ret
}
`,
		dstConcrete, srcName, dstConcrete, srcName, dstStar, dstConcrete)
	fmt.Fprintln(dest)

	// Add an error handler method
	if hasHandleError {
		fmt.Fprintf(dest, `// HandleError calls for embed.HandleError method.
func (t %v) HandleError(err error, w http.ResponseWriter, r *http.Request)bool{
	if err == nil {
		return false
	}
		return t.embed.HandleError(err, w, r)
}
`,
			dstStar)
	}

	// Add a success handler method
	if hasHandleSuccess {
		fmt.Fprintf(dest, `// HandleSuccess calls for embed.HandleSuccess method.
func (t %v) HandleSuccess(w io.Writer, r io.Reader) error {
	return t.embed.HandleSuccess(w, r)
}
`,
			dstStar)

	} else {
		fmt.Fprintf(dest, `// HandleSuccess prints http 200 and prints r.
func (t %v) HandleSuccess(w io.Writer, r io.Reader) error {
	if x, ok := w.(http.ResponseWriter); ok {
		x.WriteHeader(http.StatusOK)
		x.Header().Set("Content-Type", "application/json")
	}
	_, err := io.Copy(w, r)
	return err
}
`,
			dstStar)
	}
	fmt.Fprintln(dest)

	for _, m := range foundMethods[srcConcrete] {

		methodName := astutil.MethodName(m)
		params := astutil.MethodParams(m)
		paramNames := astutil.MethodParamNames(m)
		retVars := astutil.MethodReturnVars(m)
		sRetVars := strings.Join(retVars, ", ")
		hasErr := astutil.MethodReturnError(m)
		structProps := astutil.MethodParamsToProps(m)

		importIDs := astutil.GetSignatureImportIdentifiers(m)
		extraImports = append(extraImports, importIDs...)
		// receiverName := astutil.ReceiverName(m)
		comment := astutil.GetComment(prog, m.Pos())
		comment = makeCommentLines(comment)

		// ensure it is desired to facade this method.
		if astutil.IsExported(methodName) == false {
			continue
		}
		if methodName == "HandleError" {
			continue
		}
		if methodName == "HandleSuccess" {
			continue
		}

		// verify that the method does not take unserializable arguments.
		// todo: improve marshaller support detection.
		if !isMarshable(params) {
			break
		}

		if !isUsingConvetionnedParams(mode, params) {
			// the method params does not use
			// conventionned params names,
			// the parameters must be decoded from the
			// req body, and applied to the method.
			methInvok := fmt.Sprintf(`
				%v := t.embed.%v()
				`, sRetVars, methodName)
			if strings.TrimSpace(sRetVars) == "" {
				methInvok = fmt.Sprintf(`
					%v := t.embed.%v()
					`, sRetVars, methodName)
			}

			if params != "" {
				inputParams := "input." + strings.Join(strings.Split(paramNames, ","), ", input.")
				if astutil.MethodHasEllipse(m) {
					temp := strings.Split(paramNames, ",")
					inputParams = ""
					for i, t := range temp {
						if i == len(temp)-1 {
							inputParams += "input." + t + "..., "
						} else {
							inputParams += "input." + t + ", "
						}
					}
					inputParams = inputParams[:len(inputParams)-2]
				}

				methInvok = fmt.Sprintf(`
				input := struct{
					%v
				}{}
				decErr := json.NewDecoder(r.Body).Decode(&input)
				if decErr != nil {
					return nil, decErr
				}
			`, structProps)
				if sRetVars == "" {
					methInvok += fmt.Sprintf(`
				t.embed.%v(%v)
				`, methodName, inputParams)
				} else {
					methInvok += fmt.Sprintf(`
				%v := t.embed.%v(%v)
				`, sRetVars, methodName, inputParams)
				}
			}

			errHandling := ""
			if hasErr {
				errName := retVars[len(retVars)-1]
				errHandling = fmt.Sprintf(`if %v != nil {
							retErr = %v
			}`, errName, errName)
			}

			outHandling := fmt.Sprintf(`
				out, encErr := json.Marshal([]interface{}{%v})
				if encErr!= nil {
					retErr = encErr
				} else {
					var b bytes.Buffer
					b.Write(out)
					ret = &b
				}
					`, sRetVars)
			if sRetVars == "" {
				outHandling = ""
			}

			body := fmt.Sprintf(`
			ret := new(bytes.Buffer)
			var retErr error
			%v
			%v
			%v
			return ret, retErr
			`, methInvok, errHandling, outHandling)

			fmt.Fprintf(dest, `%v
			// Decodes r as json to invoke %v.%v.
			func (t %v) %v(r *http.Request) (io.Reader, error) {
				%v
			}`, comment, srcName, methodName, dstStar, methodName, body)
			fmt.Fprintln(dest)

		} else {
			// the method params uses
			// conventionned params names,
			// the req body should be decoded according to reqBody param,
			// other parameters are to be received/forwarded regularly.

			// the reqBody param type is set to some concrete type by the end user,
			// jsoner should decode the request body to that concrete type.

			// set the type of the reqBody of the new method to io.Reader,
			// this is what a protocol implementation d probably provide.
			targetType := ""
			lParams := strings.Split(params, ",")
			for i, p := range lParams {
				p = strings.TrimSpace(p)
				if strings.Index(p, "reqBody") == 0 {
					lParams[i] = "reqBody io.Reader"
					targetType = strings.Split(p, " ")[1]
				}
			}

			newParams := strings.Join(lParams, ",")

			// build a new list of param invokation where the input reqBody is replaced by decBody
			lParamNames := strings.Split(paramNames, ",")
			for i, p := range lParamNames {
				p = strings.TrimSpace(p)
				if p == "reqBody" {
					lParamNames[i] = "decBody"
				}
			}
			newParamNames := strings.Join(lParamNames, ",")

			// decode the reqBody into decBody
			bodyDec := ""
			if targetType != "" {
				amp := "" // & ?
				if len(targetType) > 0 && targetType[0] != '*' && targetType[0] != '[' {
					amp = "&"
				}
				bodyDec = fmt.Sprintf(`
	var decBody %v
	decErr := json.NewDecoder(reqBody).Decode(%vdecBody)
	if decErr != nil {
		return nil, decErr
	}`, targetType, amp)
			}

			// invoke the embeded method with the new params list.
			methInvok := fmt.Sprintf(`
			%v := t.embed.%v(%v)
		`, sRetVars, methodName, newParamNames)

			if strings.TrimSpace(sRetVars) == "" {
				methInvok = fmt.Sprintf(`
				t.embed.%v(%v)
			`, methodName, newParamNames)
			}

			errHandling := ""
			if hasErr {
				errName := retVars[len(retVars)-1]
				errHandling = fmt.Sprintf(`if %v != nil {
								retErr = %v
				}`, errName, errName)
			}

			outHandling := fmt.Sprintf(`
					out, encErr := json.Marshal([]interface{}{%v})
					if encErr!= nil {
						retErr = encErr
					} else {
						var b bytes.Buffer
						b.Write(out)
						ret = &b
					}
						`, sRetVars)
			if sRetVars == "" {
				outHandling = ""
			}

			body := fmt.Sprintf(`%v
%v
%v
%v
`, bodyDec, methInvok, errHandling, outHandling)

			body = fmt.Sprintf(`ret := new(bytes.Buffer)
var retErr error
%v
return ret, retErr`,
				body)

			fmt.Fprintf(dest, `%v
			// Decodes reqBody as json to invoke %v.%v.
			// Other parameters are passed straight
						func (t %v) %v(%v) (io.Reader, error) {
							%v
						}`, comment, srcName, methodName, dstStar, methodName, newParams, body)
			fmt.Fprintln(dest)
		}

	}

	return extraImports, b
}

func makeCommentLines(s string) string {
	s = strings.TrimSpace(s)
	comment := ""
	for _, k := range strings.Split(s, "\n") {
		comment += "// " + k + "\n"
	}
	return strings.TrimSpace(comment)
}

var gorillaMode = "gorilla"
var stdMode = "std"
var reqBodyVarName = "reqBody"

func isUsingConvetionnedParams(mode, params string) bool {
	lParams := strings.Split(params, ",")
	for _, param := range lParams {
		k := strings.Split(param, " ")
		if len(k) > 1 {
			varType := strings.TrimSpace(k[1])
			if varType == "http.ResponseWriter" {
				return true

			} else if varType == "*http.Request" {
				return true

			} else if varType == "httper.Cookier" {
				return true

			} else if varType == "httper.Sessionner" {
				return true
			}
		}
		varName := strings.TrimSpace(k[0])
		if isConvetionnedParam(mode, varName) {
			return true
		}
	}
	return false
}

func isConvetionnedParam(mode, varName string) bool {
	if varName == reqBodyVarName {
		return true
	}
	return getVarPrefix(mode, varName) != ""
}

func getParamConvention(mode, varName string) string {
	if varName == reqBodyVarName {
		return reqBodyVarName
	}
	return getVarPrefix(mode, varName)
}

func getSessionProviderFactory(mode string) httper.SessionProvider {
	var factory httper.SessionProvider
	if mode == stdMode {
		factory = &httper.VoidSessionProvider{}
	} else if mode == gorillaMode {
		factory = &httper.GorillaSessionProvider{}
	}
	return factory
}

func getDataProviderFactory(mode string) httper.DataerProvider {
	var factory httper.DataerProvider
	if mode == stdMode {
		factory = &httper.StdHTTPDataProvider{}
	} else if mode == gorillaMode {
		factory = &httper.GorillaHTTPDataProvider{}
	}
	return factory
}

func getDataProvider(mode string) *httper.DataProviderFacade {
	return getDataProviderFactory(mode).MakeEmpty().(*httper.DataProviderFacade)
}

func getVarPrefix(mode, varName string) string {
	ret := ""
	provider := getDataProvider(mode)
	for _, p := range provider.Providers {
		prefix := p.GetName()
		if strings.HasPrefix(varName, strings.ToLower(prefix)) {
			f := string(varName[len(prefix):][0])
			if f == strings.ToUpper(f) {
				ret = prefix
				break
			}
		} else if strings.HasPrefix(varName, strings.ToUpper(prefix)) {
			f := string(varName[len(prefix):][0])
			if f == strings.ToLower(f) {
				ret = prefix
				break
			}
		}
	}
	return ret
}

func methodsContains(typeName, search string, methods map[string][]*ast.FuncDecl) bool {
	if funList, ok := methods[typeName]; ok {
		for _, fun := range funList {
			if astutil.MethodName(fun) == search {
				return true
			}
		}
	}
	return false
}

func isMarshable(params string) bool {
	ret := true
	for _, p := range strings.Split(params, ",") {
		p = strings.TrimSpace(p)
		if len(p) > 0 {
			p = strings.Join(strings.Split(p, " ")[1:], " ") // get the type
			p = strings.TrimSpace(p)
			if strings.Index(p, "func") > -1 {
				ret = false // if its a param of type func
				break
			} else if strings.Index(p, "chan") > -1 {
				ret = false // if its a param of type chan
				break
			}
		}
	}
	return ret
}

func getPkgToLoad() string {
	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	pkgToLoad, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	return pkgToLoad[len(gopath)+1:]
}
