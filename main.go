// Package jsoner is a cli tool to implement json-rpc of a type.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/mh-cbon/astutil"
)

var name = "jsoner"
var version = "0.0.0"

func main() {

	var help bool
	var h bool
	var ver bool
	var v bool
	var outPkg string
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	flag.StringVar(&outPkg, "p", os.Getenv("GOPACKAGE"), "Package name of the new code.")

	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 2 {
		panic("wrong usage")
	}
	args := flag.Args()

	pkgToLoad := getPkgToLoad()
	dest := os.Stdout

	o := args[0]
	restargs := args[1:]

	prog := astutil.GetProgram(pkgToLoad).Package(pkgToLoad)
	// astutil.PrintPkg(p)

	// foundTypes := astutil.FindTypes(prog)
	foundMethods := astutil.FindMethods(prog)

	if o != "-" {
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			exec.Command("go", "fmt", args[0]).Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", outPkg)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintf(dest, "// github.com.mh-cbon/%v\n", name)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, "")
	fmt.Fprintf(dest, "import (\n")
	fmt.Fprintf(dest, "	%q\n", "bytes")
	fmt.Fprintf(dest, "	%q\n", "encoding/json")
	fmt.Fprintf(dest, "	%q\n", "io")
	fmt.Fprintf(dest, ")\n")

	for _, todo := range restargs {
		y := strings.Split(todo, ":")
		if len(y) != 2 {
			panic("wrong name " + todo)
		}
		srcName := y[0]
		destName := y[1]

		res := processType(destName, srcName, foundMethods)
		io.Copy(dest, &res)
	}
}

func showVer() {
	fmt.Printf("%v %v\n", name, version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	%v [-p name] [out] [...types]\n\n", name)
	fmt.Printf("	out:   Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	types: A list of types such as src:dst.\n")
	fmt.Printf("	-p:    The name of the package output.\n")
	fmt.Println()
}

func processType(destName, srcName string, foundMethods map[string][]*ast.FuncDecl) bytes.Buffer {

	var b bytes.Buffer
	dest := &b

	fmt.Fprintf(dest, `
// %v is jsoner of %v.
type %v struct{
	embed %v
}
		`, destName, srcName, destName, srcName)

	srcConcrete := astutil.GetUnpointedType(srcName)

	fmt.Fprintf(dest, `// New%v constructs a jsoner of %v
func New%v(embed %v) *%v {
	ret := &%v{
		embed: embed,
	}
  return ret
}
`,
		destName, srcName, destName, srcName, destName, destName)
	fmt.Fprintln(dest)

	for _, m := range foundMethods[srcConcrete] {

		methodName := astutil.MethodName(m)
		params := astutil.MethodParams(m)
		paramNames := astutil.MethodParamNames(m)
		retVars := astutil.MethodReturnVars(m)
		sRetVars := strings.Join(retVars, ", ")
		hasErr := astutil.MethodReturnError(m)
		structProps := astutil.MethodParamsToProps(m)
		// receiverName := astutil.ReceiverName(m)

		methInvok := fmt.Sprintf(`
%v := t.embed.%v()
`, sRetVars, methodName)

		if params != "" {
			inputParams := "input." + strings.Join(strings.Split(paramNames, ","), ", input.")
			if astutil.MethodHasEllipse(m) {
				temp := strings.Split(paramNames, ",")
				inputParams = ""
				for i, t := range temp {
					if i == len(temp)-1 {
						inputParams += "input." + t + "..., "
					} else {
						inputParams += "input." + t + ", "
					}
				}
				inputParams = inputParams[:len(inputParams)-2]
			}

			methInvok = fmt.Sprintf(`
	input := struct{
		%v
	}{}
	decErr := json.NewDecoder(args).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}
	%v := t.embed.%v(%v)
`, structProps, sRetVars, methodName, inputParams)
		}

		errHandling := ""
		if hasErr {
			errName := retVars[len(retVars)-1]
			errHandling = fmt.Sprintf(`if %v != nil {
				retErr = %v
}`, errName, errName)
		}

		outHandling := fmt.Sprintf(`
	out, encErr := json.Marshal([]interface{}{%v})
	if encErr!= nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}
		`, sRetVars)

		body := fmt.Sprintf(`
var ret io.Reader
var retErr error
%v
%v
%v
return ret, retErr
`, methInvok, errHandling, outHandling)

		fmt.Fprintf(dest, `// %v reads json, outputs json.
// the json input must provide a key/value for each params.
func (t %v) %v(args io.Reader) (io.Reader, error) {
	%v
}`,
			methodName, destName, methodName, body)
		fmt.Fprintln(dest)
	}

	return b
}

func getPkgToLoad() string {
	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	pkgToLoad, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	return pkgToLoad[len(gopath)+1:]
}
