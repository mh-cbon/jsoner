package main

// file generated by
// github.com/mh-cbon/jsoner
// do not edit

import (
	"bytes"
	"encoding/json"
	jsoner "github.com/mh-cbon/jsoner/lib"
	"io"
	"net/http"
)

// TomatesJSONGen is jsoner of *TomatesGen.
// TomatesGen implements a typed slice of Tomate
type TomatesJSONGen struct {
	embed     *TomatesGen
	finalizer jsoner.Finalizer
}

// NewTomatesJSONGen constructs a jsoner of *TomatesGen
func NewTomatesJSONGen(embed *TomatesGen, finalizer jsoner.Finalizer) *TomatesJSONGen {
	if finalizer == nil {
		finalizer = &jsoner.JSONFinalizer{}
	}
	ret := &TomatesJSONGen{
		embed:     embed,
		finalizer: finalizer,
	}
	return ret
}

//UnmarshalJSON JSON unserializes TomatesJSONGen
func (t *TomatesJSONGen) UnmarshalJSON(b []byte) error {
	var embed *TomatesGen
	if err := json.Unmarshal(b, &embed); err != nil {
		return err
	}
	t.embed = embed
	return nil
}

//MarshalJSON JSON serializes TomatesJSONGen
func (t *TomatesJSONGen) MarshalJSON() ([]byte, error) {
	return json.Marshal(t.embed)
}

// Push Decodes r as json to invoke *TomatesGen.Push.
// Push appends every Tomate
func (t *TomatesJSONGen) Push(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar0 := t.embed.Push(input.Arg0...)

	output := struct {
		Arg0 *TomatesGen
	}{
		Arg0: retVar0,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Unshift Decodes r as json to invoke *TomatesGen.Unshift.
// Unshift prepends every Tomate
func (t *TomatesJSONGen) Unshift(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar1 := t.embed.Unshift(input.Arg0...)

	output := struct {
		Arg0 *TomatesGen
	}{
		Arg0: retVar1,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Pop Decodes r as json to invoke *TomatesGen.Pop.
// Pop removes then returns the last Tomate.
func (t *TomatesJSONGen) Pop(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	retVar2 := t.embed.Pop()

	output := struct {
		Arg0 Tomate
	}{
		Arg0: retVar2,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Shift Decodes r as json to invoke *TomatesGen.Shift.
// Shift removes then returns the first Tomate.
func (t *TomatesJSONGen) Shift(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	retVar3 := t.embed.Shift()

	output := struct {
		Arg0 Tomate
	}{
		Arg0: retVar3,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Index Decodes r as json to invoke *TomatesGen.Index.
// Index of given Tomate. It must implements Ider interface.
func (t *TomatesJSONGen) Index(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar4 := t.embed.Index(input.Arg0)

	output := struct {
		Arg0 int
	}{
		Arg0: retVar4,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Contains Decodes r as json to invoke *TomatesGen.Contains.
// Contains returns true if s in is t.
func (t *TomatesJSONGen) Contains(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar5 := t.embed.Contains(input.Arg0)

	output := struct {
		Arg0 bool
	}{
		Arg0: retVar5,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// RemoveAt Decodes r as json to invoke *TomatesGen.RemoveAt.
// RemoveAt removes a Tomate at index i.
func (t *TomatesJSONGen) RemoveAt(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar6 := t.embed.RemoveAt(input.Arg0)

	output := struct {
		Arg0 bool
	}{
		Arg0: retVar6,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Remove Decodes r as json to invoke *TomatesGen.Remove.
// Remove removes given Tomate
func (t *TomatesJSONGen) Remove(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar7 := t.embed.Remove(input.Arg0)

	output := struct {
		Arg0 bool
	}{
		Arg0: retVar7,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// InsertAt Decodes r as json to invoke *TomatesGen.InsertAt.
// InsertAt adds given Tomate at index i
func (t *TomatesJSONGen) InsertAt(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 int
		Arg1 Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar8 := t.embed.InsertAt(input.Arg0, input.Arg1)

	output := struct {
		Arg0 *TomatesGen
	}{
		Arg0: retVar8,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Splice Decodes r as json to invoke *TomatesGen.Splice.
// Splice removes and returns a slice of Tomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *TomatesJSONGen) Splice(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 int
		Arg1 int
		Arg2 []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar9 := t.embed.Splice(input.Arg0, input.Arg1, input.Arg2...)

	output := struct {
		Arg0 []Tomate
	}{
		Arg0: retVar9,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Slice Decodes r as json to invoke *TomatesGen.Slice.
// Slice returns a copied slice of Tomate, starting at start, ending at start+length.
func (t *TomatesJSONGen) Slice(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 int
		Arg1 int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar10 := t.embed.Slice(input.Arg0, input.Arg1)

	output := struct {
		Arg0 []Tomate
	}{
		Arg0: retVar10,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Reverse Decodes r as json to invoke *TomatesGen.Reverse.
// Reverse the slice.
func (t *TomatesJSONGen) Reverse(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	retVar11 := t.embed.Reverse()

	output := struct {
		Arg0 *TomatesGen
	}{
		Arg0: retVar11,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Len Decodes r as json to invoke *TomatesGen.Len.
// Len of the slice.
func (t *TomatesJSONGen) Len(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	retVar12 := t.embed.Len()

	output := struct {
		Arg0 int
	}{
		Arg0: retVar12,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Set Decodes r as json to invoke *TomatesGen.Set.
// Set the slice.
func (t *TomatesJSONGen) Set(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar13 := t.embed.Set(input.Arg0)

	output := struct {
		Arg0 *TomatesGen
	}{
		Arg0: retVar13,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// Get Decodes r as json to invoke *TomatesGen.Get.
// Get the slice.
func (t *TomatesJSONGen) Get(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	retVar14 := t.embed.Get()

	output := struct {
		Arg0 []Tomate
	}{
		Arg0: retVar14,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}

// At Decodes r as json to invoke *TomatesGen.At.
// At return the item at index i.
func (t *TomatesJSONGen) At(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error
	input := struct {
		Arg0 int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar15 := t.embed.At(input.Arg0)

	output := struct {
		Arg0 Tomate
	}{
		Arg0: retVar15,
	}

	outBytes, encErr := json.Marshal(output)
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(outBytes)
		ret = &b
	}

	return ret, retErr

}
