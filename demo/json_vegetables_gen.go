package demo

// file generated by
// github.com/mh-cbon/jsoner
// do not edit

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
)

// Tomates implements a typed slice of Tomate.
// JSONTomates is jsoner of *Tomates.
type JSONTomates struct {
	embed *Tomates
}

// NewJSONTomates constructs a jsoner of *Tomates
func NewJSONTomates(embed *Tomates) *JSONTomates {
	ret := &JSONTomates{
		embed: embed,
	}
	return ret
}

// HandleSuccess prints http 200 and prints r.
func (t *JSONTomates) HandleSuccess(w io.Writer, r io.Reader) error {
	if x, ok := w.(http.ResponseWriter); ok {
		x.WriteHeader(http.StatusOK)
		x.Header().Set("Content-Type", "application/json")
	}
	_, err := io.Copy(w, r)
	return err
}

// Push appends every Tomate
// Decodes r as json to invoke *Tomates.Push.
func (t *JSONTomates) Push(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar0 := t.embed.Push(input.x...)

	out, encErr := json.Marshal([]interface{}{retVar0})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Unshift prepends every Tomate
// Decodes r as json to invoke *Tomates.Unshift.
func (t *JSONTomates) Unshift(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar1 := t.embed.Unshift(input.x...)

	out, encErr := json.Marshal([]interface{}{retVar1})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Pop removes then returns the last Tomate.
// Decodes r as json to invoke *Tomates.Pop.
func (t *JSONTomates) Pop(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar2 := t.embed.Pop()

	out, encErr := json.Marshal([]interface{}{retVar2})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Shift removes then returns the first Tomate.
// Decodes r as json to invoke *Tomates.Shift.
func (t *JSONTomates) Shift(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar3 := t.embed.Shift()

	out, encErr := json.Marshal([]interface{}{retVar3})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Index of given Tomate. It must implements Ider interface.
// Decodes r as json to invoke *Tomates.Index.
func (t *JSONTomates) Index(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar4 := t.embed.Index(input.s)

	out, encErr := json.Marshal([]interface{}{retVar4})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Contains returns true if s in is t.
// Decodes r as json to invoke *Tomates.Contains.
func (t *JSONTomates) Contains(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar5 := t.embed.Contains(input.s)

	out, encErr := json.Marshal([]interface{}{retVar5})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// RemoveAt removes a Tomate at index i.
// Decodes r as json to invoke *Tomates.RemoveAt.
func (t *JSONTomates) RemoveAt(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		i int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar6 := t.embed.RemoveAt(input.i)

	out, encErr := json.Marshal([]interface{}{retVar6})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Remove removes given Tomate
// Decodes r as json to invoke *Tomates.Remove.
func (t *JSONTomates) Remove(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar7 := t.embed.Remove(input.s)

	out, encErr := json.Marshal([]interface{}{retVar7})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// InsertAt adds given Tomate at index i
// Decodes r as json to invoke *Tomates.InsertAt.
func (t *JSONTomates) InsertAt(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		i int
		s Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar8 := t.embed.InsertAt(input.i, input.s)

	out, encErr := json.Marshal([]interface{}{retVar8})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Splice removes and returns a slice of Tomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
// Decodes r as json to invoke *Tomates.Splice.
func (t *JSONTomates) Splice(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		start  int
		length int
		s      []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar9 := t.embed.Splice(input.start, input.length, input.s...)

	out, encErr := json.Marshal([]interface{}{retVar9})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Slice returns a copied slice of Tomate, starting at start, ending at start+length.
// Decodes r as json to invoke *Tomates.Slice.
func (t *JSONTomates) Slice(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		start  int
		length int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar10 := t.embed.Slice(input.start, input.length)

	out, encErr := json.Marshal([]interface{}{retVar10})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Reverse the slice.
// Decodes r as json to invoke *Tomates.Reverse.
func (t *JSONTomates) Reverse(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar11 := t.embed.Reverse()

	out, encErr := json.Marshal([]interface{}{retVar11})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Len of the slice.
// Decodes r as json to invoke *Tomates.Len.
func (t *JSONTomates) Len(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar12 := t.embed.Len()

	out, encErr := json.Marshal([]interface{}{retVar12})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Set the slice.
// Decodes r as json to invoke *Tomates.Set.
func (t *JSONTomates) Set(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		x []Tomate
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar13 := t.embed.Set(input.x)

	out, encErr := json.Marshal([]interface{}{retVar13})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// Get the slice.
// Decodes r as json to invoke *Tomates.Get.
func (t *JSONTomates) Get(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	retVar14 := t.embed.Get()

	out, encErr := json.Marshal([]interface{}{retVar14})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}

// At return the item at index i.
// Decodes r as json to invoke *Tomates.At.
func (t *JSONTomates) At(r *http.Request) (io.Reader, error) {

	ret := new(bytes.Buffer)
	var retErr error

	input := struct {
		i int
	}{}
	decErr := json.NewDecoder(r.Body).Decode(&input)
	if decErr != nil {
		return nil, decErr
	}

	retVar15 := t.embed.At(input.i)

	out, encErr := json.Marshal([]interface{}{retVar15})
	if encErr != nil {
		retErr = encErr
	} else {
		var b bytes.Buffer
		b.Write(out)
		ret = &b
	}

	return ret, retErr

}
